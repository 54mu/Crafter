	--mechanics to follow rails
	ride_rail = function(self)
		local pos = vector.floor(vector.add(self.object:getpos(),0.5))
		local speed = self.speed
		if self.speed > 10 then
			self.speed = 10
		end
		
		local vel = self.object:getvelocity()
		local x = math.abs(vel.x)
		local z = math.abs(vel.z)
		local xdir
		local zdir
		local dir = {x=0,y=0,z=0}
		
		--check direction
		--x axis
		if x > z then
			if vel.x>0 then xdir=1 elseif vel.x<0 then xdir=-1 end
			
			--print(minetest.get_node(vector.new(pos.x,pos.y,pos.z)).name)
			
			--go up
			if is_rail(pos.x+xdir,pos.y+1,pos.z) or (not is_rail(pos.x,pos.y,pos.z) and is_rail(pos.x+xdir,pos.y,pos.z)) then
				--print("up")
				dir.y = speed
				dir.x = xdir*speed

			--go down
			elseif (is_rail(pos.x,pos.y-1,pos.z) or vel.y < 0) and not is_rail(pos.x+xdir,pos.y,pos.z) then
				--print("down")
				dir.y = -speed
				dir.x = xdir*speed
			
			--go flat
			elseif is_rail(pos.x,pos.y,pos.z) then --currently on rail
				--print("flat")
				--print("forward inside")
				--correct y position
				if dir.y == 0 and self.object:getpos().y ~= pos.y then
					--print("correcting y")
					local posser = self.object:getpos()
					self.object:moveto(vector.new(posser.x,pos.y,posser.z))
				end
				dir.x = xdir*speed
			end
		--z axis
		elseif z > x then
			if vel.z>0 then zdir=1 elseif vel.z<0 then zdir=-1 end
			
			--print(minetest.get_node(vector.new(pos.x,pos.y,pos.z)).name)
			
			--go up
			if is_rail(pos.x,pos.y+1,pos.z+zdir) or (not is_rail(pos.x,pos.y,pos.z) and is_rail(pos.x,pos.y,pos.z+zdir)) then
				--print("up")
				dir.y = speed
				dir.z = zdir*speed
			
			--go down
			elseif (is_rail(pos.x,pos.y-1,pos.z) or vel.y < 0) and not is_rail(pos.x,pos.y,pos.z+zdir) then
				--print("down")
				dir.y = -speed
				dir.z = zdir*speed
			
			
			--go flat
			elseif is_rail(pos.x,pos.y,pos.z) then --currently on rail
				--print("flat")
				--print("forward inside")
				--correct y position
				if dir.y == 0 and self.object:getpos().y ~= pos.y then
					--print("correcting y")
					local posser = self.object:getpos()
					self.object:moveto(vector.new(posser.x,pos.y,posser.z))
				end
				dir.z = zdir*speed
			end
		end
		--turn
		local turnx = 0
		local turnz = 0
		
		if vel.x>0 then turnx=1 elseif vel.x<0 then turnx=-1 end
		if vel.z>0 then turnz=1 elseif vel.z<0 then turnz=-1 end
		

		if turnx and turnz and dir.y == 0 and not vector.equals(dir, vector.new(0,0,0)) and not is_rail(pos.x+turnx,pos.y-1,pos.z+turnz) and not is_rail(pos.x+turnx,pos.y,pos.z+turnz) and not is_rail(pos.x+turnx,pos.y+1,pos.z+turnz) then
			if x > z then
				for y = -1,1 do
					if is_rail(pos.x,pos.y+y,pos.z+1) then
						dir.z = speed
						dir.x = 0
						--recenter on the rail
						self.object:moveto(pos)
					elseif is_rail(pos.x,pos.y+y,pos.z-1) then
						dir.z = -speed
						dir.x = 0
						--recenter on the rail
						self.object:moveto(pos)
					end
				end
			elseif z > x then
				for y = -1,1 do
					if is_rail(pos.x+1,pos.y+y,pos.z) then
						dir.x = speed
						dir.z = 0
						--recenter on the rail
						self.object:moveto(pos)
					elseif is_rail(pos.x-1,pos.y+y,pos.z) then
						dir.x = -speed
						dir.z = 0
						--recenter on the rail
						self.object:moveto(pos)
					end
				end
			end
			
		end
		--apply
		--if not vector.equals(dir,vector.new(0,0,0)) then
		self.object:setvelocity(dir)
		--end
		self.oldpos=self.object:getpos()
		
		--make the cart move up and down on hills
		self.object:set_properties({mesh="minecart.obj"})
		if vel.y <0  then
			self.object:set_properties({mesh="minecart_down.obj"})
		elseif vel.y > 0 then
			self.object:set_properties({mesh="minecart_up.obj"})
		end
		
		--slow it down
		if self.speed > 0 then
			self.speed = self.speed - 0.01
		end
		if self.speed < 0 then
			self.speed = 0
		end
		
	end,
